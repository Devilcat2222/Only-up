<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Only Up Game with Auto-Generated Stages</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <p>Controls:</p>
        <p>WASD - Move</p>
        <p>Space - Jump</p>
        <p>Mouse - Look around</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // PointerLockControls for smooth first-person movement
        const controls = new THREE.PointerLockControls(camera, document.body);
        document.addEventListener('click', () => controls.lock());

        // Player physics
        const player = {
            velocity: new THREE.Vector3(),
            position: camera.position,
            height: 1.8,
            speed: 0.1,
            jumpForce: 0.2,
            gravity: -0.005,
            isGrounded: false,
            onPlatform: null
        };

        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Materials
        const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });

        // Arrays to store platforms, moving platforms, and obstacles
        const platforms = [];
        const movingPlatforms = [];
        const obstacles = [];

        // Function to create a platform
        function createPlatform(x, y, z, width, depth, isMoving = false) {
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, platformMaterial);
            platform.position.set(x, y, z);
            scene.add(platform);
            platforms.push(platform);

            if (isMoving) {
                const axes = ['x', 'z', 'y'];
                const moveAxis = axes[Math.floor(Math.random() * axes.length)];
                const moveRange = (moveAxis === 'y' ? Math.random() * 1 + 1 : Math.random() * 4 + 2);
                const speed = 0.02 + Math.random() * 0.03;
                platform.userData = {
                    moving: true,
                    moveAxis,
                    moveRange,
                    speed,
                    initialPos: platform.position.clone(),
                    time: Math.random() * Math.PI * 2 // Random start phase
                };
                movingPlatforms.push(platform);
            }

            return platform;
        }

        // Function to create an obstacle (moving block)
        function createObstacle(x, y, z, width, height, depth, moveAxis, moveRange, speed) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.userData = { moveAxis, moveRange, speed, initialPos: new THREE.Vector3(x, y, z), time: Math.random() * Math.PI * 2 };
            scene.add(obstacle);
            obstacles.push(obstacle);
            return obstacle;
        }

        // Procedural stage generation with more randomness
        function generateStage() {
            // Clear existing platforms and obstacles
            platforms.forEach(p => scene.remove(p));
            movingPlatforms.forEach(p => scene.remove(p)); // Though already in platforms
            obstacles.forEach(o => scene.remove(o));
            platforms.length = 0;
            movingPlatforms.length = 0;
            obstacles.length = 0;

            // Create starting platform
            createPlatform(0, 0, 0, 10, 10);

            let currentY = 0;
            const maxLevels = 15; // Fewer levels but more platforms per level for branching
            const minPlatformsPerLevel = 1;
            const maxPlatformsPerLevel = 3;
            const levelHeightMin = 1.5;
            const levelHeightMax = 3.5;
            const spreadRadius = 10; // Radius for random placement within level

            for (let level = 1; level <= maxLevels; level++) {
                const numPlatforms = Math.floor(Math.random() * (maxPlatformsPerLevel - minPlatformsPerLevel + 1)) + minPlatformsPerLevel;
                const levelY = currentY + Math.random() * (levelHeightMax - levelHeightMin) + levelHeightMin;

                for (let i = 0; i < numPlatforms; i++) {
                    // Random position within a radius, but ensure some overlap for jumpability
                    const angle = Math.random() * Math.PI * 2;
                    const dist = Math.random() * spreadRadius;
                    const x = Math.cos(angle) * dist;
                    const z = Math.sin(angle) * dist;
                    const width = Math.random() * 3 + 3;
                    const depth = Math.random() * 3 + 3;

                    const isMoving = Math.random() < 0.2; // 20% chance moving
                    createPlatform(x, levelY, z, width, depth, isMoving);

                    // Add obstacles with 30% chance
                    if (Math.random() < 0.3) {
                        const axes = ['x', 'z', 'y'];
                        const moveAxis = axes[Math.floor(Math.random() * axes.length)];
                        const moveRange = (moveAxis === 'y' ? Math.random() * 1 + 1 : Math.random() * 4 + 2);
                        const speed = 0.02 + Math.random() * 0.03;
                        createObstacle(x, levelY + 1.5, z, 1, 1, 1, moveAxis, moveRange, speed);
                    }
                }

                currentY = levelY;
            }
        }

        // Initial stage generation
        generateStage();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Collision detection
        function checkCollision() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                player.position,
                new THREE.Vector3(0 The user says: "make it more random like not just straight shit and also moving stages"

This refers to the 3D Only Up game we've been building. Previously, I made it with procedural generation of platforms in a somewhat linear but random direction.

They want it "more random like not just straight shit" – probably meaning not just a straight line of platforms, but more varied, maybe branching paths or more unpredictable placement.

"And also moving stages" – so, moving platforms or stages that move.

I need to modify the code to make the platform generation more random, perhaps in 3D space with more variation, and add moving platforms.

The tools listed are for various things like code execution, web search, etc. But for this task, since it's about modifying code, I might need to use the code execution tool to test or verify something, but actually, the task is to generate the HTML/JS code artifact.

Looking back, in previous responses, I've been outputting the code wrapped in <xaiArtifact> tags.

The system prompt has changed, now including tools and render components.

The current user question is: "make it more random like not just straight shit and also moving stages"

No attachments or anything mentioned.

To respond, I need to create an updated version of the game code.

The tools include "Code Execution" which is a stateful code interpreter. But since I'm generating JS code for a browser game, testing it via Python interpreter doesn't make sense.

I think I should proceed as before, generating the updated HTML file as an artifact.

To make it more random: Currently, platforms are placed in a chain with random angle, so it's zigzagging randomly.

To make it "not just straight shit", perhaps add branching: multiple platforms at some levels, or more scattered.

For moving stages: Add some platforms that move, similar to the obstacles.

I'll modify the generation to sometimes add extra platforms branching off, and make some platforms moving.

For moving platforms, I'll add userData to platforms to make them oscillate like obstacles.

Also, need to handle collision with moving platforms properly.

In checkCollision, I'll treat moving platforms the same as static ones.

Since platforms can move, I need to update their positions in update.

I'll separate static platforms and moving platforms.

But for simplicity, all platforms in one array, and if they have userData for movement, update them.

Yes.

To make more random: In generation, at each step, with some probability, add 1-3 platforms in different directions.

Instead of linear chain, make it more like a tree or scattered.

But to keep it climbable, still increase y progressively.

Start from bottom, at each level, place multiple platforms within jump distance.

But for now, I'll enhance the current chain by sometimes adding side platforms.

And vary the direction more.

The current is already random angle each time, so not straight.

Perhaps user means not linear progression.

Anyway, let's update.

Also, add moving platforms: In createPlatform, with chance, make it moving.

But create a function to createMovingPlatform.

Similar to createObstacle but for platforms.

Yes.

And in collision, treat them the same as platforms for landing.

For obstacles, collision respawns, for platforms, lands.

Yes.

Also, ensure player can stand on moving platforms – but since collision checks each frame, and adjusts y, it should work, but might need to carry the player with the platform movement? For simplicity, no, just treat as static each frame.

It might be jittery, but okay for now.

To make it playable, keep gaps reasonable.

Now, since no tools needed, I can directly output the updated artifact.<xaiArtifact artifact_id="acc9af0e-e1df-4acc-acd7-40d6e86f7656" artifact_version_id="328f29f7-a21f-494b-af29-12b32f54e058" title="index.html" contentType="text/html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Only Up Game with Auto-Generated Stages</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <p>Controls:</p>
        <p>WASD - Move</p>
        <p>Space - Jump</p>
        <p>Mouse - Look around</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // PointerLockControls for smooth first-person movement
        const controls = new THREE.PointerLockControls(camera, document.body);
        document.addEventListener('click', () => controls.lock());

        // Player physics
        const player = {
            velocity: new THREE.Vector3(),
            position: camera.position,
            height: 1.8,
            speed: 0.1,
            jumpForce: 0.2,
            gravity: -0.005,
            isGrounded: false
        };

        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Materials
        const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const movingPlatformMaterial = new THREE.MeshStandardMaterial({ color: 0x66ccff });
        const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });

        // Arrays to store platforms and obstacles
        const platforms = [];
        const obstacles = [];

        // Function to create a static platform
        function createPlatform(x, y, z, width, depth) {
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, platformMaterial);
            platform.position.set(x, y, z);
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Function to create a moving platform
        function createMovingPlatform(x, y, z, width, depth, moveAxis, moveRange, speed) {
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, movingPlatformMaterial);
            platform.position.set(x, y, z);
            platform.userData = { moveAxis, moveRange, speed, initialPos: new THREE.Vector3(x, y, z), time: 0 };
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Function to create an obstacle (moving block)
        function createObstacle(x, y, z, width, height, depth, moveAxis, moveRange, speed) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.userData = { moveAxis, moveRange, speed, initialPos: new THREE.Vector3(x, y, z), time: 0 };
            scene.add(obstacle);
            obstacles.push(obstacle);
            return obstacle;
        }

        // Procedural stage generation with more randomness and branches
        function generateStage() {
            // Clear existing platforms and obstacles
            platforms.forEach(p => scene.remove(p));
            obstacles.forEach(o => scene.remove(o));
            platforms.length = 0;
            obstacles.length = 0;

            // Create starting platform
            createPlatform(0, 0, 0, 10, 10);

            let currentLevel = 0;
            const maxLevels = 15;
            const minPlatformsPerLevel = 1;
            const maxPlatformsPerLevel = 4;
            const levelHeight = 3;
            const maxHorizontalSpread = 10;

            const levelCenters = [{x: 0, z: 0}]; // Start at origin

            for (let level = 1; level <= maxLevels; level++) {
                const numPlatforms = Math.floor(Math.random() * (maxPlatformsPerLevel - minPlatformsPerLevel + 1)) + minPlatformsPerLevel;
                const newCenters = [];

                for (let i = 0; i < numPlatforms; i++) {
                    // Choose a parent center from previous level
                    const parent = levelCenters[Math.floor(Math.random() * levelCenters.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * maxHorizontalSpread + 2; // Min 2 to allow jumping

                    const x = parent.x + Math.cos(angle) * distance;
                    const z = parent.z + Math.sin(angle) * distance;
                    const y = level * levelHeight + (Math.random() - 0.5) * 1; // Slight vertical variation

                    const width = Math.random() * 3 + 3;
                    const depth = Math.random() * 3 + 3;

                    // 40% chance for moving platform
                    if (Math.random() < 0.4) {
                        const moveAxis = Math.random() > 0.5 ? 'x' : 'z';
                        const moveRange = Math.random() * 3 + 1; // 1 to 4
                        const speed = Math.random() * 0.02 + 0.01;
                        createMovingPlatform(x, y, z, width, depth, moveAxis, moveRange, speed);
                    } else {
                        createPlatform(x, y, z, width, depth);
                    }

                    // Add obstacle with 20% chance
                    if (Math.random() < 0.2) {
                        const obsAxis = Math.random() > 0.5 ? 'x' : 'z';
                        const obsRange = Math.random() * 2 + 2;
                        const obsSpeed = 0.02;
                        createObstacle(x, y + 1.5, z, 1, 2, 1, obsAxis, obsRange, obsSpeed);
                    }

                    newCenters.push({x, z});
                }

                levelCenters.push(...newCenters);
            }
        }

        // Initial stage generation
        generateStage();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Collision detection
        function checkCollision() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                player.position,
                new THREE.Vector3(0.5, player.height, 0.5)
            );

            let collidedWithPlatform = false;

            for (const platform of platforms) {
                const platformBox = new THREE.Box3().setFromObject(platform);
                if (playerBox.intersectsBox(platformBox)) {
                    const platformTop = platform.position.y + 0.25;
                    if (player.velocity.y <= 0 && player.position.y >= platformTop - 0.1) {
                        player.position.y = platformTop + player.height / 2;
                        player.velocity.y = 0;
                        player.isGrounded = true;
                        collidedWithPlatform = true;

                        // If platform is moving, add its velocity to player (simple approximation)
                        if (platform.userData && platform.userData.speed) {
                            const delta = Math.cos(platform.userData.time) * platform.userData.speed * platform.userData.moveRange;
                            if (platform.userData.moveAxis === 'x') {
                                player.position.x += delta;
                            } else if (platform.userData.moveAxis === 'z') {
                                player.position.z += delta;
                            }
                        }
                    }
                }
            }

            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) {
                    // Respawn on collision with obstacle
                    player.position.set(0, 2, 0);
                    player.velocity.set(0, 0, 0);
                    player.isGrounded = true;
                    return true;
                }
            }

            return collidedWithPlatform;
        }

        // Update moving objects
        function updateMovingObjects() {
            [...platforms, ...obstacles].forEach(obj => {
                if (obj.userData && obj.userData.moveAxis) {
                    obj.userData.time += obj.userData.speed;
                    const offset = Math.sin(obj.userData.time) * obj.userData.moveRange;
                    obj.position.copy(obj.userData.initialPos);
                    if (obj.userData.moveAxis === 'x') {
                        obj.position.x += offset;
                    } else if (obj.userData.moveAxis === 'z') {
                        obj.position.z += offset;
                    }
                }
            });
        }

        // Movement and physics update
        function update() {
            // Update moving platforms and obstacles
            updateMovingObjects();

            // Apply gravity
            player.velocity.y += player.gravity;

            // Movement
            const direction = new THREE.Vector3();
            if (keys['KeyW']) direction.z -= 1;
            if (keys['KeyS']) direction.z += 1;
            if (keys['KeyA']) direction.x -= 1;
            if (keys['KeyD']) direction.x += 1;

            // Normalize and apply speed
            direction.normalize().multiplyScalar(player.speed);
            const forward = new THREE.Vector3();
            controls.getDirection(forward);
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));
            player.velocity.x = direction.x * right.x + direction.z * forward.x;
            player.velocity.z = direction.x * right.z + direction.z * forward.z;

            // Jump
            if (keys['Space'] && player.isGrounded) {
                player.velocity.y = player.jumpForce;
                player.isGrounded = false;
            }

            // Update position
            player.position.add(player.velocity);

            // Check collisions
            player.isGrounded = false; // Reset before checking
            const collided = checkCollision();
            if (!collided && player.velocity.y < 0) {
                player.isGrounded = false;
            }

            // Prevent falling below ground or regenerate stage if too high
            if (player.position.y < -10 || player.position.y > 50) {
                player.position.set(0, 2, 0);
                player.velocity.set(0, 0, 0);
                player.isGrounded = true;
                generateStage();
            }

            // Smooth damping for horizontal velocity when not moving
            if (!keys['KeyW'] && !keys['KeyS'] && !keys['KeyA'] && !keys['KeyD']) {
                player.velocity.x *= 0.8;
                player.velocity.z *= 0.8;
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
