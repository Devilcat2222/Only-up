<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Only Up Game with Auto-Generated Stages</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #ui {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            color: black;
            font-size: 30px;
            text-align: center;
            pointer-events: none;
        }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            display: none;
        }
        #game-over button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
        #game-over button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <p>Controls:</p>
        <p>WASD - Move</p>
        <p>Space - Jump (super jump if holding coil)</p>
        <p>Mouse - Look around</p>
        <p>Left Click - Shoot if holding gun</p>
    </div>
    <div id="ui">
        <p id="lives">Lives: 3</p>
        <p id="item">Item: None</p>
        <p id="height">Height: 0</p>
    </div>
    <div id="crosshair">+</div>
    <div id="game-over">
        <h1>Game Over</h1>
        <p id="max-height">Max Height: 0</p>
        <button onclick="respawn()">Respawn</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // PointerLockControls
        const controls = new THREE.PointerLockControls(camera, document.body);
        document.addEventListener('click', () => {
            if (!gameOver) controls.lock();
        });

        // Player physics
        const player = {
            velocity: new THREE.Vector3(),
            position: camera.position,
            height: 1.8,
            speed: 0.1,
            jumpForce: 0.2,
            gravity: -0.005,
            isGrounded: false,
            onPlatform: null,
            lives: 3,
            currentItem: null,
            maxHeight: 0
        };

        // Game state
        let gameOver = false;

        // Gun model (for holding)
        const gunGeometry = new THREE.BoxGeometry(0.3, 0.2, 0.8);
        const gunMaterial = new THREE.MeshStandardMaterial({ color: 0xff9900 });
        const gun = new THREE.Mesh(gunGeometry, gunMaterial);
        gun.position.set(0.5, -0.5, -0.7);
        gun.rotation.y = Math.PI / -8;
        gun.visible = false;
        camera.add(gun);
        scene.add(camera);

        // UI elements
        const livesText = document.getElementById('lives');
        const itemText = document.getElementById('item');
        const heightText = document.getElementById('height');
        const gameOverScreen = document.getElementById('game-over');
        const maxHeightText = document.getElementById('max-height');

        function updateUI() {
            livesText.textContent = `Lives: ${player.lives}`;
            itemText.textContent = `Item: ${player.currentItem ? player.currentItem : 'None'}`;
            heightText.textContent = `Height: ${Math.floor(player.position.y)}`;
            gun.visible = player.currentItem === 'gun';
        }

        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Mouse click for shooting
        renderer.domElement.addEventListener('mousedown', (e) => {
            if (controls.isLocked && player.currentItem === 'gun' && !gameOver) {
                shootGun();
            }
        });

        // Materials
        const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const movingPlatformMaterial = new THREE.MeshStandardMaterial({ color: 0x66ccff });
        const spinningPlatformMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
        const slippyPlatformMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });
        const coilMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff99, emissive: 0x00ff99, emissiveIntensity: 0.5 });
        const droneMaterial = new THREE.MeshStandardMaterial({ color: 0x3333ff });
        const projectileMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
        const gunItemMaterial = new THREE.MeshStandardMaterial({ color: 0xff9900, emissive: 0xff9900, emissiveIntensity: 0.5 });

        // Arrays to store objects
        const platforms = [];
        const obstacles = [];
        const items = [];
        const drones = [];
        const projectiles = [];

        // Function to create a static platform
        function createPlatform(x, y, z, width, depth, options = {}) {
            const material = options.slippy ? slippyPlatformMaterial : platformMaterial;
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, z);
            if (options.slippy) platform.userData.slippy = true;
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Function to create a moving platform
        function createMovingPlatform(x, y, z, width, depth, moveAxis, moveRange, speed, options = {}) {
            const material = options.slippy ? slippyPlatformMaterial : movingPlatformMaterial;
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, z);
            platform.userData = { 
                moveAxis, 
                moveRange, 
                speed, 
                initialPos: new THREE.Vector3(x, y, z), 
                time: Math.random() * Math.PI * 2 
            };
            if (options.slippy) platform.userData.slippy = true;
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Function to create a spinning platform
        function createSpinningPlatform(x, y, z, width, depth, spinSpeed, options = {}) {
            const material = options.slippy ? slippyPlatformMaterial : spinningPlatformMaterial;
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, z);
            platform.userData = { 
                spinSpeed,
                slippy: options.slippy || false
            };
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Function to create an obstacle (moving block)
        function createObstacle(x, y, z, width, height, depth, moveAxis, moveRange, speed) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.userData = { 
                moveAxis, 
                moveRange, 
                speed, 
                initialPos: new THREE.Vector3(x, y, z), 
                time: Math.random() * Math.PI * 2 
            };
            scene.add(obstacle);
            obstacles.push(obstacle);
            return obstacle;
        }

        // Function to create an item
        function createItem(type, x, y, z) {
            let item;
            if (type === 'coil') {
                const geometry = new THREE.TorusGeometry(0.4, 0.1, 16, 32);
                item = new THREE.Mesh(geometry, coilMaterial);
            } else {
                // Gun as a group of barrel and handle
                item = new THREE.Group();
                const barrelGeometry = new THREE.BoxGeometry(0.2, 0.2, 0.8);
                const handleGeometry = new THREE.BoxGeometry(0.2, 0.4, 0.2);
                const barrelMesh = new THREE.Mesh(barrelGeometry, gunItemMaterial);
                const handleMesh = new THREE.Mesh(handleGeometry, gunItemMaterial);
                handleMesh.position.set(0, -0.3, 0.3);
                item.add(barrelMesh);
                item.add(handleMesh);
            }
            item.position.set(x, y + 1, z);
            item.userData = { type };
            scene.add(item);
            items.push(item);
            return item;
        }

        // Function to create a drone
        function createDrone(x, y, z) {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const drone = new THREE.Mesh(geometry, droneMaterial);
            drone.position.set(x, y + 3, z);
            drone.userData = {
                shootTimer: Math.random() * 100 + 100,
                velocity: new THREE.Vector3((Math.random() - 0.5) * 0.02, 0, (Math.random() - 0.5) * 0.02)
            };
            scene.add(drone);
            drones.push(drone);
            return drone;
        }

        // Function to create a projectile
        function createProjectile(pos, dir) {
            const geometry = new THREE.SphereGeometry(0.2, 8, 8);
            const projectile = new THREE.Mesh(geometry, projectileMaterial);
            projectile.position.copy(pos);
            projectile.userData = { velocity: dir.clone().normalize().multiplyScalar(0.1) };
            scene.add(projectile);
            projectiles.push(projectile);
            return projectile;
        }

        // Procedural stage generation
        function generateStage() {
            platforms.forEach(p => scene.remove(p));
            obstacles.forEach(o => scene.remove(o));
            items.forEach(i => scene.remove(i));
            drones.forEach(d => scene.remove(d));
            projectiles.forEach(pr => scene.remove(pr));
            platforms.length = 0;
            obstacles.length = 0;
            items.length = 0;
            drones.length = 0;
            projectiles.length = 0;

            player.currentItem = null;
            player.maxHeight = 0;
            updateUI();

            createPlatform(0, 0, 0, 10, 10);

            let currentLevel = 0;
            const maxLevels = 15;
            const minPlatformsPerLevel = 1;
            const maxPlatformsPerLevel = 4;
            const levelHeight = 3;
            const maxHorizontalSpread = 10;
            let droneSpawned = false;

            const levelCenters = [{x: 0, z: 0}];

            for (let level = 1; level <= maxLevels; level++) {
                const numPlatforms = Math.floor(Math.random() * (maxPlatformsPerLevel - minPlatformsPerLevel + 1)) + minPlatformsPerLevel;
                const newCenters = [];

                for (let i = 0; i < numPlatforms; i++) {
                    const parent = levelCenters[Math.floor(Math.random() * levelCenters.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * maxHorizontalSpread + 2;

                    const x = parent.x + Math.cos(angle) * distance;
                    const z = parent.z + Math.sin(angle) * distance;
                    const y = level * levelHeight + (Math.random() - 0.5) * 1;

                    const width = Math.random() * 5 + 1;
                    const depth = Math.random() * 5 + 1;

                    const isSlippy = Math.random() < 0.2;
                    const options = { slippy: isSlippy };

                    const rand = Math.random();
                    let platform;
                    if (rand < 0.3) {
                        const moveAxis = Math.random() > 0.5 ? 'x' : 'z';
                        const moveRange = Math.random() * 3 + 1;
                        const speed = Math.random() * 0.02 + 0.01;
                        platform = createMovingPlatform(x, y, z, width, depth, moveAxis, moveRange, speed, options);
                    } else if (rand < 0.5) {
                        const spinSpeed = (Math.random() * 0.02 + 0.01) * (Math.random() < 0.5 ? 1 : -1);
                        platform = createSpinningPlatform(x, y, z, width, depth, spinSpeed, options);
                    } else {
                        platform = createPlatform(x, y, z, width, depth, options);
                    }

                    if (Math.random() < 0.1) {
                        const itemType = Math.random() < 0.5 ? 'coil' : 'gun';
                        createItem(itemType, x, y, z);
                    }

                    if (!droneSpawned && Math.random() < 0.05) {
                        createDrone(x, y, z);
                        droneSpawned = true;
                    }

                    if (Math.random() < 0.2) {
                        const obsAxis = Math.random() > 0.5 ? 'x' : 'z';
                        const obsRange = Math.random() * 2 + 2;
                        const obsSpeed = 0.02;
                        createObstacle(x, y + 1.5, z, 1, 2, 1, obsAxis, obsRange, obsSpeed);
                    }

                    newCenters.push({x, z});
                }

                levelCenters.push(...newCenters);
            }
        }

        // Initial stage generation
        generateStage();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Raycaster for shooting
        const raycaster = new THREE.Raycaster();

        function shootGun() {
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(drones);
            if (intersects.length > 0) {
                const hitDrone = intersects[0].object;
                scene.remove(hitDrone);
                drones.splice(drones.indexOf(hitDrone), 1);
            }
            player.currentItem = null;
            updateUI();
        }

        // Respawn function
        function respawn() {
            gameOver = false;
            gameOverScreen.style.display = 'none';
            player.position.set(0, 2, 0);
            player.velocity.set(0, 0, 0);
            player.isGrounded = true;
            player.lives = 3;
            player.currentItem = null;
            player.maxHeight = 0;
            controls.lock();
            generateStage();
            updateUI();
        }

        // Collision detection
        function checkCollision() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                player.position,
                new THREE.Vector3(0.5, player.height, 0.5)
            );

            let collidedWithPlatform = false;

            for (const platform of platforms) {
                const platformBox = new THREE.Box3().setFromObject(platform);
                if (playerBox.intersectsBox(platformBox)) {
                    const platformTop = platform.position.y + 0.25;
                    if (player.velocity.y <= 0 && player.position.y >= platformTop - 0.1) {
                        player.position.y = platformTop + player.height / 2;
                        player.velocity.y = 0;
                        player.isGrounded = true;
                        player.onPlatform = platform;
                        collidedWithPlatform = true;

                        if (platform.userData.moveAxis) {
                            const delta = Math.cos(platform.userData.time) * platform.userData.speed * platform.userData.moveRange;
                            if (platform.userData.moveAxis === 'x') {
                                player.position.x += delta;
                            } else if (platform.userData.moveAxis === 'z') {
                                player.position.z += delta;
                            }
                        }
                    }
                }
            }

            for (let i = items.length - 1; i >= 0; i--) {
                const item = items[i];
                const itemBox = new THREE.Box3().setFromObject(item);
                if (playerBox.intersectsBox(itemBox) && !player.currentItem) {
                    player.currentItem = item.userData.type;
                    scene.remove(item);
                    items.splice(i, 1);
                    updateUI();
                }
            }

            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                const projBox = new THREE.Box3().setFromObject(proj);
                if (playerBox.intersectsBox(projBox)) {
                    player.lives -= 1;
                    updateUI();
                    scene.remove(proj);
                    projectiles.splice(i, 1);
                    if (player.lives <= 0) {
                        showGameOver();
                    }
                } else {
                    let hitPlatform = false;
                    for (const platform of platforms) {
                        const platformBox = new THREE.Box3().setFromObject(platform);
                        if (projBox.intersectsBox(platformBox)) {
                            scene.remove(proj);
                            projectiles.splice(i, 1);
                            hitPlatform = true;
                            break;
                        }
                    }
                    if (!hitPlatform && (proj.position.y < -20 || proj.position.distanceTo(player.position) > 100)) {
                        scene.remove(proj);
                        projectiles.splice(i, 1);
                    }
                }
            }

            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) {
                    showGameOver();
                    return true;
                }
            }

            if (!collidedWithPlatform) {
                player.onPlatform = null;
            }

            return collidedWithPlatform;
        }

        function showGameOver() {
            gameOver = true;
            gameOverScreen.style.display = 'block';
            maxHeightText.textContent = `Max Height: ${Math.floor(player.maxHeight)}`;
            controls.unlock();
        }

        function resetGame() {
            player.position.set(0, 2, 0);
            player.velocity.set(0, 0, 0);
            player.isGrounded = true;
            player.lives = 3;
            player.currentItem = null;
            player.maxHeight = 0;
            generateStage();
            updateUI();
        }

        // Update moving and spinning objects
        function updateMovingObjects() {
            platforms.forEach(obj => {
                if (obj.userData.moveAxis) {
                    obj.userData.time += obj.userData.speed;
                    const offset = Math.sin(obj.userData.time) * obj.userData.moveRange;
                    obj.position.copy(obj.userData.initialPos);
                    if (obj.userData.moveAxis === 'x') {
                        obj.position.x += offset;
                    } else if (obj.userData.moveAxis === 'z') {
                        obj.position.z += offset;
                    }
                } else if (obj.userData.spinSpeed) {
                    obj.rotation.y += obj.userData.spinSpeed;
                }
            });

            obstacles.forEach(obj => {
                if (obj.userData.moveAxis) {
                    obj.userData.time += obj.userData.speed;
                    const offset = Math.sin(obj.userData.time) * obj.userData.moveRange;
                    obj.position.copy(obj.userData.initialPos);
                    if (obj.userData.moveAxis === 'x') {
                        obj.position.x += offset;
                    } else if (obj.userData.moveAxis === 'z') {
                        obj.position.z += offset;
                    }
                }
            });
        }

        // Update drones and projectiles
        function updateDronesAndProjectiles() {
            drones.forEach(drone => {
                drone.position.add(drone.userData.velocity);
                if (Math.random() < 0.01) {
                    drone.userData.velocity.set((Math.random() - 0.5) * 0.02, 0, (Math.random() - 0.5) * 0.02);
                }

                drone.userData.shootTimer -= 1;
                if (drone.userData.shootTimer <= 0) {
                    const dir = player.position.clone().sub(drone.position);
                    createProjectile(drone.position, dir);
                    drone.userData.shootTimer = 200 + Math.random() * 100;
                }
            });

            projectiles.forEach(proj => {
                proj.position.add(proj.userData.velocity);
            });
        }

        // Movement and physics update
        function update() {
            if (gameOver) return;

            updateMovingObjects();
            updateDronesAndProjectiles();

            player.velocity.y += player.gravity;

            const direction = new THREE.Vector3();
            if (keys['KeyW']) direction.z -= 1;
            if (keys['KeyS']) direction.z += 1;
            if (keys['KeyA']) direction.x -= 1;
            if (keys['KeyD']) direction.x += 1;

            direction.normalize().multiplyScalar(player.speed);
            const forward = new THREE.Vector3();
            controls.getDirection(forward);
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));
            player.velocity.x = direction.x * right.x + direction.z * forward.x;
            player.velocity.z = direction.x * right.z + direction.z * forward.z;

            if (keys['Space'] && player.isGrounded) {
                let force = player.jumpForce;
                if (player.currentItem === 'coil') {
                    force *= 2;
                    player.currentItem = null;
                    updateUI();
                }
                player.velocity.y = force;
                player.isGrounded = false;
                player.onPlatform = null;
            }

            player.position.add(player.velocity);

            player.maxHeight = Math.max(player.maxHeight, player.position.y);

            player.isGrounded = false;
            const collided = checkCollision();
            if (!collided && player.velocity.y < 0) {
                player.isGrounded = false;
            }

            let damping = 0.9;
            if (player.isGrounded && player.onPlatform && player.onPlatform.userData.slippy) {
                damping = 0.99;
            }
            player.velocity.x *= damping;
            player.velocity.z *= damping;

            if (player.position.y < -10 || player.position.y > 50) {
                showGameOver();
            }

            updateUI();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
