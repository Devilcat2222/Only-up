<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Only Up Game with Auto-Generated Stages</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <p>Controls:</p>
        <p>WASD - Move</p>
        <p>Space - Jump</p>
        <p>Mouse - Look around</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 50);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // PointerLockControls for smooth first-person movement
        const controls = new THREE.PointerLockControls(camera, document.body);
        document.addEventListener('click', () => controls.lock());

        // Player physics
        const player = {
            velocity: new THREE.Vector3(),
            position: camera.position,
            height: 1.8,
            speed: 0.1,
            jumpForce: 0.2,
            gravity: -0.005,
            isGrounded: false
        };

        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Materials
        const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });

        // Arrays to store platforms and obstacles
        const platforms = [];
        const obstacles = [];

        // Function to create a platform
        function createPlatform(x, y, z, width, depth) {
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, platformMaterial);
            platform.position.set(x, y, z);
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Function to create an obstacle (moving block)
        function createObstacle(x, y, z, width, height, depth, moveAxis, moveRange, speed) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.userData = { moveAxis, moveRange, speed, initialPos: new THREE.Vector3(x, y, z), time: 0 };
            scene.add(obstacle);
            obstacles.push(obstacle);
            return obstacle;
        }

        // Procedural stage generation
        function generateStage() {
            // Clear existing platforms and obstacles (except starting platform)
            platforms.forEach(platform => scene.remove(platform));
            obstacles.forEach(obstacle => scene.remove(obstacle));
            platforms.length = 0;
            obstacles.length = 0;

            // Create starting platform
            createPlatform(0, 0, 0, 10, 10);

            let lastX = 0, lastZ = 0, lastY = 0;
            const maxPlatforms = 20;
            const minGap = 3;
            const maxGap = 6;
            const maxHeightStep = 2.5;

            for (let i = 0; i < maxPlatforms; i++) {
                // Randomize platform size and position
                const width = Math.random() * 3 + 3; // 3 to 6
                const depth = Math.random() * 3 + 3;
                const heightStep = Math.random() * maxHeightStep + 1;
                const gap = Math.random() * (maxGap - minGap) + minGap;
                const angle = Math.random() * Math.PI * 2;
                const x = lastX + Math.cos(angle) * gap;
                const z = lastZ + Math.sin(angle) * gap;
                const y = lastY + heightStep;

                createPlatform(x, y, z, width, depth);

                // Add obstacles with 30% chance
                if (Math.random() < 0.3 && i > 0) {
                    const moveAxis = Math.random() > 0.5 ? 'x' : 'z';
                    const moveRange = Math.random() * 2 + 2; // 2 to 4
                    createObstacle(x, y + 1, z, 1, 1, 1, moveAxis, moveRange, 0.02);
                }

                lastX = x;
                lastZ = z;
                lastY = y;
            }
        }

        // Initial stage generation
        generateStage();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Collision detection
        function checkCollision() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                player.position,
                new THREE.Vector3(0.5, player.height, 0.5)
            );

            for (const platform of platforms) {
                const platformBox = new THREE.Box3().setFromObject(platform);
                if (playerBox.intersectsBox(platformBox)) {
                    const platformTop = platform.position.y + 0.25;
                    if (player.position.y > platformTop) {
                        player.position.y = platformTop + player.height / 2;
                        player.velocity.y = 0;
                        player.isGrounded = true;
                        return true;
                    }
                }
            }

            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) {
                    // Respawn on collision with obstacle
                    player.position.set(0, 2, 0);
                    player.velocity.set(0, 0, 0);
                    player.isGrounded = true;
                    return true;
                }
            }
            return false;
        }

        // Update obstacles
        function updateObstacles() {
            obstacles.forEach(obstacle => {
                obstacle.userData.time += obstacle.userData.speed;
                const offset = Math.sin(obstacle.userData.time) * obstacle.userData.moveRange;
                obstacle.position.copy(obstacle.userData.initialPos);
                if (obstacle.userData.moveAxis === 'x') {
                    obstacle.position.x += offset;
                } else {
                    obstacle.position.z += offset;
                }
            });
        }

        // Movement and physics update
        function update() {
            // Apply gravity
            player.velocity.y += player.gravity;

            // Movement
            const direction = new THREE.Vector3();
            if (keys['KeyW']) direction.z -= 1;
            if (keys['KeyS']) direction.z += 1;
            if (keys['KeyA']) direction.x -= 1;
            if (keys['KeyD']) direction.x += 1;

            // Normalize and apply speed
            direction.normalize().multiplyScalar(player.speed);
            const forward = new THREE.Vector3();
            controls.getDirection(forward);
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));
            player.velocity.x = direction.x * right.x + direction.z * forward.x;
            player.velocity.z = direction.x * right.z + direction.z * forward.z;

            // Jump
            if (keys['Space'] && player.isGrounded) {
                player.velocity.y = player.jumpForce;
                player.isGrounded = false;
            }

            // Update position
            player.position.add(player.velocity);

            // Check collisions
            if (!checkCollision() && player.velocity.y < 0) {
                player.isGrounded = false;
            }

            // Prevent falling below ground or regenerate stage if too high
            if (player.position.y < -10 || player.position.y > 50) {
                player.position.set(0, 2, 0);
                player.velocity.set(0, 0, 0);
                player.isGrounded = true;
                generateStage();
            }

            // Update obstacles
            updateObstacles();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
