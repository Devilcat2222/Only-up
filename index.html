<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Only Up Game with Auto-Generated Stages</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <p>Controls:</p>
        <p>WASD - Move</p>
        <p>Space - Jump</p>
        <p>Mouse - Look around</p>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.Fog(0x87ceeb, 10, 100);

        // Camera
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 0);

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // PointerLockControls for smooth first-person movement
        const controls = new THREE.PointerLockControls(camera, document.body);
        document.addEventListener('click', () => controls.lock());

        // Player physics
        const player = {
            velocity: new THREE.Vector3(),
            position: camera.position,
            height: 1.8,
            speed: 0.1,
            jumpForce: 0.2,
            gravity: -0.005,
            isGrounded: false,
            onPlatform: null
        };

        // Keyboard controls
        const keys = {};
        document.addEventListener('keydown', (e) => keys[e.code] = true);
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Materials
        const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const movingPlatformMaterial = new THREE.MeshStandardMaterial({ color: 0x66ccff });
        const spinningPlatformMaterial = new THREE.MeshStandardMaterial({ color: 0xffcc00 });
        const slippyPlatformMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const obstacleMaterial = new THREE.MeshStandardMaterial({ color: 0xff3333 });

        // Arrays to store platforms and obstacles
        const platforms = [];
        const obstacles = [];

        // Function to create a static platform
        function createPlatform(x, y, z, width, depth, options = {}) {
            const material = options.slippy ? slippyPlatformMaterial : platformMaterial;
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, z);
            if (options.slippy) platform.userData.slippy = true;
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Function to create a moving platform
        function createMovingPlatform(x, y, z, width, depth, moveAxis, moveRange, speed, options = {}) {
            const material = options.slippy ? slippyPlatformMaterial : movingPlatformMaterial;
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, z);
            platform.userData = { 
                moveAxis, 
                moveRange, 
                speed, 
                initialPos: new THREE.Vector3(x, y, z), 
                time: Math.random() * Math.PI * 2 
            };
            if (options.slippy) platform.userData.slippy = true;
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Function to create a spinning platform
        function createSpinningPlatform(x, y, z, width, depth, spinSpeed, options = {}) {
            const material = options.slippy ? slippyPlatformMaterial : spinningPlatformMaterial;
            const geometry = new THREE.BoxGeometry(width, 0.5, depth);
            const platform = new THREE.Mesh(geometry, material);
            platform.position.set(x, y, z);
            platform.userData = { 
                spinSpeed,
                slippy: options.slippy || false
            };
            scene.add(platform);
            platforms.push(platform);
            return platform;
        }

        // Function to create an obstacle (moving block)
        function createObstacle(x, y, z, width, height, depth, moveAxis, moveRange, speed) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const obstacle = new THREE.Mesh(geometry, obstacleMaterial);
            obstacle.position.set(x, y, z);
            obstacle.userData = { 
                moveAxis, 
                moveRange, 
                speed, 
                initialPos: new THREE.Vector3(x, y, z), 
                time: Math.random() * Math.PI * 2 
            };
            scene.add(obstacle);
            obstacles.push(obstacle);
            return obstacle;
        }

        // Procedural stage generation with more randomness and branches
        function generateStage() {
            // Clear existing platforms and obstacles
            platforms.forEach(p => scene.remove(p));
            obstacles.forEach(o => scene.remove(o));
            platforms.length = 0;
            obstacles.length = 0;

            // Create starting platform
            createPlatform(0, 0, 0, 10, 10);

            let currentLevel = 0;
            const maxLevels = 15;
            const minPlatformsPerLevel = 1;
            const maxPlatformsPerLevel = 4;
            const levelHeight = 3;
            const maxHorizontalSpread = 10;

            const levelCenters = [{x: 0, z: 0}]; // Start at origin

            for (let level = 1; level <= maxLevels; level++) {
                const numPlatforms = Math.floor(Math.random() * (maxPlatformsPerLevel - minPlatformsPerLevel + 1)) + minPlatformsPerLevel;
                const newCenters = [];

                for (let i = 0; i < numPlatforms; i++) {
                    // Choose a parent center from previous level
                    const parent = levelCenters[Math.floor(Math.random() * levelCenters.length)];
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * maxHorizontalSpread + 2; // Min 2 to allow jumping

                    const x = parent.x + Math.cos(angle) * distance;
                    const z = parent.z + Math.sin(angle) * distance;
                    const y = level * levelHeight + (Math.random() - 0.5) * 1; // Slight vertical variation

                    const width = Math.random() * 5 + 1; // 1 to 6 for narrow platforms
                    const depth = Math.random() * 5 + 1; // 1 to 6 for narrow platforms

                    const isSlippy = Math.random() < 0.2; // 20% chance slippy
                    const options = { slippy: isSlippy };

                    const rand = Math.random();
                    if (rand < 0.3) {
                        // Moving platform
                        const moveAxis = Math.random() > 0.5 ? 'x' : 'z';
                        const moveRange = Math.random() * 3 + 1; // 1 to 4
                        const speed = Math.random() * 0.02 + 0.01;
                        createMovingPlatform(x, y, z, width, depth, moveAxis, moveRange, speed, options);
                    } else if (rand < 0.5) {
                        // Spinning platform
                        const spinSpeed = (Math.random() * 0.02 + 0.01) * (Math.random() < 0.5 ? 1 : -1); // Random direction
                        createSpinningPlatform(x, y, z, width, depth, spinSpeed, options);
                    } else {
                        // Static platform
                        createPlatform(x, y, z, width, depth, options);
                    }

                    // Add obstacle with 20% chance
                    if (Math.random() < 0.2) {
                        const obsAxis = Math.random() > 0.5 ? 'x' : 'z';
                        const obsRange = Math.random() * 2 + 2;
                        const obsSpeed = 0.02;
                        createObstacle(x, y + 1.5, z, 1, 2, 1, obsAxis, obsRange, obsSpeed);
                    }

                    newCenters.push({x, z});
                }

                levelCenters.push(...newCenters);
            }
        }

        // Initial stage generation
        generateStage();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Collision detection
        function checkCollision() {
            const playerBox = new THREE.Box3().setFromCenterAndSize(
                player.position,
                new THREE.Vector3(0.5, player.height, 0.5)
            );

            let collidedWithPlatform = false;

            for (const platform of platforms) {
                const platformBox = new THREE.Box3().setFromObject(platform);
                if (playerBox.intersectsBox(platformBox)) {
                    const platformTop = platform.position.y + 0.25;
                    if (player.velocity.y <= 0 && player.position.y >= platformTop - 0.1) {
                        player.position.y = platformTop + player.height / 2;
                        player.velocity.y = 0;
                        player.isGrounded = true;
                        player.onPlatform = platform;
                        collidedWithPlatform = true;

                        // If platform is moving, add its velocity to player (simple approximation)
                        if (platform.userData.moveAxis) {
                            const delta = Math.cos(platform.userData.time) * platform.userData.speed * platform.userData.moveRange;
                            if (platform.userData.moveAxis === 'x') {
                                player.position.x += delta;
                            } else if (platform.userData.moveAxis === 'z') {
                                player.position.z += delta;
                            }
                        }
                    }
                }
            }

            for (const obstacle of obstacles) {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (playerBox.intersectsBox(obstacleBox)) {
                    // Respawn on collision with obstacle
                    player.position.set(0, 2, 0);
                    player.velocity.set(0, 0, 0);
                    player.isGrounded = true;
                    player.onPlatform = null;
                    return true;
                }
            }

            if (!collidedWithPlatform) {
                player.onPlatform = null;
            }

            return collidedWithPlatform;
        }

        // Update moving and spinning objects
        function updateMovingObjects() {
            platforms.forEach(obj => {
                if (obj.userData.moveAxis) {
                    obj.userData.time += obj.userData.speed;
                    const offset = Math.sin(obj.userData.time) * obj.userData.moveRange;
                    obj.position.copy(obj.userData.initialPos);
                    if (obj.userData.moveAxis === 'x') {
                        obj.position.x += offset;
                    } else if (obj.userData.moveAxis === 'z') {
                        obj.position.z += offset;
                    }
                } else if (obj.userData.spinSpeed) {
                    obj.rotation.y += obj.userData.spinSpeed;
                }
            });

            obstacles.forEach(obj => {
                if (obj.userData.moveAxis) {
                    obj.userData.time += obj.userData.speed;
                    const offset = Math.sin(obj.userData.time) * obj.userData.moveRange;
                    obj.position.copy(obj.userData.initialPos);
                    if (obj.userData.moveAxis === 'x') {
                        obj.position.x += offset;
                    } else if (obj.userData.moveAxis === 'z') {
                        obj.position.z += offset;
                    }
                }
            });
        }

        // Movement and physics update
        function update() {
            // Update moving platforms and obstacles
            updateMovingObjects();

            // Apply gravity
            player.velocity.y += player.gravity;

            // Movement (reverted to original signs)
            const direction = new THREE.Vector3();
            if (keys['KeyW']) direction.z -= 1; // Forward
            if (keys['KeyS']) direction.z += 1; // Backward
            if (keys['KeyA']) direction.x -= 1;
            if (keys['KeyD']) direction.x += 1;

            // Normalize and apply speed
            direction.normalize().multiplyScalar(player.speed);
            const forward = new THREE.Vector3();
            controls.getDirection(forward);
            const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0, 1, 0));
            player.velocity.x = direction.x * right.x + direction.z * forward.x;
            player.velocity.z = direction.x * right.z + direction.z * forward.z;

            // Jump
            if (keys['Space'] && player.isGrounded) {
                player.velocity.y = player.jumpForce;
                player.isGrounded = false;
                player.onPlatform = null;
            }

            // Update position
            player.position.add(player.velocity);

            // Check collisions
            player.isGrounded = false; // Reset before checking
            const collided = checkCollision();
            if (!collided && player.velocity.y < 0) {
                player.isGrounded = false;
            }

            // Apply damping based on platform type
            let damping = 0.9;
            if (player.isGrounded && player.onPlatform && player.onPlatform.userData.slippy) {
                damping = 0.99; // Less damping for slippery
            }
            player.velocity.x *= damping;
            player.velocity.z *= damping;

            // Prevent falling below ground or regenerate stage if too high
            if (player.position.y < -10 || player.position.y > 50) {
                player.position.set(0, 2, 0);
                player.velocity.set(0, 0, 0);
                player.isGrounded = true;
                player.onPlatform = null;
                generateStage();
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            update();
            renderer.render(scene, camera);
        }
        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
